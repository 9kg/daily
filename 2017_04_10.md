RSA加密算法
两个大质数p,q
乘积n=p*q
小于n且与n互质的数的个数 r=φ(n)=(p-1)(q-1)---->(欧拉函数)
任取一个小于r且与r互质的整数e,计算出e关于模r的模反元素d
即:e*d ≡ 1( mod r)    ---->e*d%r=1
此时(n,e)和(n,d)即为产生的公钥私钥

假设传输的消息为msg
加密后的消息:_msg = msg^e%n;
对加密消息解密:msg = _msg^d%n;

let p=5,q=11,n=p*q;  //(n=55)
let r=(p-1)(q-1);   //(r=40)

//e需要小于55且e与55互质,e可取7,11,13,17,19,23...

let e=7;      //7*d%40=1 ==> d=23;
//let e=11;   11*d%40=1 ==> d=11;
//let e=13;   13*d%40=1 ==> d=37;
//...

//(55,7)  (55,23)

//加密
let incodeMsg = msg =>  Math.pow(msg,7)%55

//解密
let decodeMsg = msg => Math.pow(msg,23)%55

//由于n=55所以传送的msg需要小于55,真实中的rsa应用  p,q都是大质数

let _msg = incodeMsg(13)  //_msg = Math.pow(13,7)%55 (= 7)

let msg = decodeMsg(_msg) //msg = Math.pow(7,23)%55 (= 13)  --->  7 ** 23超过了js的Number.MAX_SAFE_INTEGER 计算会失真

